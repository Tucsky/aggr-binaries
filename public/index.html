<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AGGR Candles Viewer</title>
    <style>
      body {
        margin: 0;
        background: #0d1117;
        color: #e6edf3;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
      #app {
        position: relative;
        height: 98vh;
      }
      #controls-toggle {
        position: absolute;
        top: 8px;
        left: 10px;
        z-index: 11;
        background: #161b22e6;
        border: 1px solid #30363d;
        color: #e6edf3;
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 10px;
        cursor: pointer;
      }
      #status {
        position: absolute;
        right: 4px;
        top: 4px;
      }
      #status.idle {
        color: #6a737d;
      }
      #status.idle::before {
        content: "⏳ ";
      }
      #status.connected {
        color: #28a745;
      }
      #status.connected::before {
        content: "✅ ";
      }
      #status.closed, #status.error {
        color: #d73a49;
      }
      #status.closed::before, #status.error::before {
        content: "❌ ";
      }
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        padding: 8px 12px;
        background: #161b22e6;
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 10px;
        align-items: start;
        border: 1px solid #30363d;
        border-radius: 6px;
        z-index: 10;
      }
      #chart {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      input {
        background: #0d1117;
        border: 1px solid #30363d;
        color: #e6edf3;
        padding: 4px 6px;
        font-size: 10px;
      }
      button {
        background: #238636;
        color: #fff;
        border: none;
        padding: 6px 10px;
        cursor: pointer;
      }
    </style>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  </head>
  <body>
    <div id="app">
      <button id="controls-toggle">Show controls</button>
      <div id="controls">
        <label>Collector <input id="collector" size="6" /></label>
        <label>Exchange <input id="exchange" size="10" /></label>
        <label>Symbol <input id="symbol" size="10" /></label>
        <label>Start (UTC) <input id="start" type="datetime-local" /></label>
        <button id="connect">Connect</button>
        <span id="status" class="idle">idle</span>
      </div>
      <div id="chart"></div>
    </div>
    <script type="module">
      const chartEl = document.getElementById("chart");
      const chart = LightweightCharts.createChart(chartEl, {
        layout: { background: { color: "#0d1117" }, textColor: "#e6edf3" },
        grid: { vertLines: { color: "#161b22" }, horzLines: { color: "#161b22" } },
        timeScale: {
          rightOffset: 1,
          barSpacing: 6,
          fixLeftEdge: false,
          timeVisible: true,
          secondsVisible: false,
        },
        priceScale: {
          mode: LightweightCharts.PriceScaleMode.Logarithmic,
        },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
      });
      const series = chart.addCandlestickSeries({ upColor: "#16a34a", downColor: "#ef4444", wickUpColor: "#16a34a", wickDownColor: "#ef4444" });
      function loadPrefs() {
        try {
          const raw = localStorage.getItem("aggr-viewer-prefs");
          if (!raw) return;
          const prefs = JSON.parse(raw);
          if (prefs.collector) document.getElementById("collector").value = prefs.collector;
          if (prefs.exchange) document.getElementById("exchange").value = prefs.exchange;
          if (prefs.symbol) document.getElementById("symbol").value = prefs.symbol;
          if (prefs.start) document.getElementById("start").value = prefs.start;
        } catch {
          // ignore
        }
      }

      function savePrefs() {
        const prefs = {
          collector: document.getElementById("collector").value.trim(),
          exchange: document.getElementById("exchange").value.trim(),
          symbol: document.getElementById("symbol").value.trim(),
          start: document.getElementById("start").value,
        };
        try {
          localStorage.setItem("aggr-viewer-prefs", JSON.stringify(prefs));
        } catch {
          // ignore
        }
      }

      loadPrefs();
      if (!document.getElementById("collector").value) document.getElementById("collector").value = "PI";
      if (!document.getElementById("exchange").value) document.getElementById("exchange").value = "BITFINEX";
      if (!document.getElementById("symbol").value) document.getElementById("symbol").value = "BTCUSD";
      if (!document.getElementById("start").value) document.getElementById("start").valueAsNumber = new Date();
      setControlsVisible(true);
      let ws = null;
      let meta = null;
      const cache = new Map(); // key: index -> candle (with time)
      let lastRequested = { fromIndex: 0, toIndex: 0 };
      let loadedIndex = { min: null, max: null };
      let suppressRangeEvent = false;
      let TIMEFRAME = 1000 * 60;
      let META_SPARSE = false;
      let META_RECORDS = 0;
      let anchorIndex = null;

      function setStatus(msg) {
        document.getElementById("status").textContent = msg;
        document.getElementById("status").classList.add(msg)

        switch (msg) {
          case "idle":
            document.getElementById("connect").innerText = "Reconnect";
            break;
          case "connected":
            document.getElementById("connect").innerText = "Disconnect";
            break;
          case "closed":
            document.getElementById("connect").innerText = "Reconnect";
            break;
          case "error":
            document.getElementById("connect").innerText = "Reconnect";
            break;
        }
      }

      function connect() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.close();
          ws.onclose()
          loadedIndex = { min: null, max: null };
          lastRequested = { fromIndex: 0, toIndex: 0 };
          cache.clear();
          series.setData([]);
          return;
        } 

        const collector = document.getElementById("collector").value.trim().toUpperCase();
        const exchange = document.getElementById("exchange").value.trim().toUpperCase();
        const symbol = document.getElementById("symbol").value.trim();
        const startStr = document.getElementById("start").value;
        const startMs = startStr ? Date.parse(startStr) : null;
        savePrefs();
        if (!collector || !exchange || !symbol) return;
        if (ws) ws.close();
        cache.clear();
        meta = null;
        series.setData([]);
        loadedIndex = { min: null, max: null };
        lastRequested = { fromIndex: 0, toIndex: 0 };

        const url = `ws://localhost:${location.port || 3000}/ws?collector=${collector}&exchange=${exchange}&symbol=${symbol}${startMs ? `&start=${startMs}` : ""}`;
        ws = new WebSocket(url);
        ws.onopen = () => setStatus("connected");
        ws.onclose = () => setStatus("closed");
        ws.onerror = () => setStatus("error");
        ws.onmessage = (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === "meta") {
            meta = msg;
            console.log("[ws] meta", msg);
            TIMEFRAME = msg.timeframeMs ?? 60_000;
            META_SPARSE = Boolean(msg.sparse);
            META_RECORDS = msg.records ?? 0;
            anchorIndex = msg.anchorIndex ?? (META_RECORDS > 0 ? META_RECORDS - 1 : 0);
            const windowMs = TIMEFRAME * 500;
            requestSlice(Math.max(0, anchorIndex - 1499), anchorIndex);
          } else if (msg.type === "candles") {
            console.log("[ws] candles idx", msg.fromIndex, msg.toIndex, "count", msg.candles.length);
            ingest(msg.fromIndex, msg.candles);
          }
        };
      }

      function ingest(fromIndex, candles) {
        let newMinIdx = loadedIndex.min;
        let newMaxIdx = loadedIndex.max;
        candles.forEach((c, i) => {
          const idx = fromIndex + i;
          // if ((c.buyCount ?? 0) + (c.sellCount ?? 0) === 0) continue; // skip empty candles rendered as zeros
          cache.set(idx, { ...c, index: idx });
          if (newMinIdx === null || idx < newMinIdx) newMinIdx = idx;
          if (newMaxIdx === null || idx > newMaxIdx) newMaxIdx = idx;
        });
        loadedIndex = { min: newMinIdx, max: newMaxIdx };
        const sorted = Array.from(cache.entries())
          .sort((a, b) => a[0] - b[0])
          .map(([, c]) => c);
        suppressRangeEvent = true;
        series.setData(
          sorted.map((c) => ({
            time: Math.floor(c.time / 1000),
            open: c.open,
            high: c.high,
            low: c.low,
            close: c.close,
          })),
        );
        suppressRangeEvent = false;
      }

      function requestSlice(fromIndex, toIndex) {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        if (!meta) return;
        const clampedFrom = Math.max(0, Math.min(META_RECORDS - 1, fromIndex));
        const clampedTo = Math.max(0, Math.min(META_RECORDS - 1, toIndex));
        if (lastRequested.fromIndex === clampedFrom && lastRequested.toIndex === clampedTo) return;
        lastRequested = { fromIndex: clampedFrom, toIndex: clampedTo };
        console.log("[ws] request slice", clampedFrom, "->", clampedTo);
        ws.send(JSON.stringify({ type: "slice", fromIndex: clampedFrom, toIndex: clampedTo }));
      }

      chart.timeScale().subscribeVisibleTimeRangeChange((range) => {
        if (suppressRangeEvent) return;
        if (!range || !range.from || !range.to) return;
        const from = Math.floor(Number(range.from) * 1000);
        const to = Math.floor(Number(range.to) * 1000);
        if (loadedIndex.min === null || loadedIndex.max === null || cache.size === 0) return;

        const cachedArr = Array.from(cache.values()).sort((a, b) => a.time - b.time);
        const minTime = cachedArr[0].time;
        const maxTime = cachedArr[cachedArr.length - 1].time;

        if (from < minTime + TIMEFRAME) {
          console.log("[chart] need more left");
          const nextFrom = Math.max(0, loadedIndex.min - 2000);
          requestSlice(nextFrom, loadedIndex.min - 1);
        }
        if (to > maxTime - TIMEFRAME) {
          console.log("[chart] need more right");
          const nextTo = Math.min(META_RECORDS - 1, loadedIndex.max + 2000);
          requestSlice(loadedIndex.max + 1, nextTo);
        }
      });

      document.getElementById("connect").addEventListener("click", connect);
      document.getElementById("controls-toggle").addEventListener("click", () => {
        const controls = document.getElementById("controls");
        const isHidden = controls.style.display === "none";
        setControlsVisible(isHidden);
      });

      function setControlsVisible(show) {
        const controls = document.getElementById("controls");
        const toggle = document.getElementById("controls-toggle");
        controls.style.display = show ? "flex" : "none";
        toggle.textContent = show ? "Hide controls" : "Show controls";
      }
    </script>
  </body>
</html>
